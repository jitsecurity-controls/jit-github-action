name: 'Jit security-controls action'
description: 'Runs a Jit security-control on a target dir'
inputs:
  docker_user:
    description: 'user for docker registry'
    required: true
  docker_password:
    description: 'password for docker registry'
    required: true
  container_args:
    description: 'container additional args'
    required: false
    default: ""
  security_control:
    description: "Docker image tag path of security control to execute"
    required: true
  security_control_args:
    description: "argument to pass to the security control"
    required: false
  security_control_output_file:
    description: "path to the security control output"
    required: false
    default: ""
  dispatch_type:
    description: "'workflow' or 'repository' (dispatch_type is deprecated and will be removed)"
    required: false
    default: "workflow"
  fail_on_findings:
    description: "fail control when finding is found"
    required: false
    default: true
  runner_setup:
    description: RunnerSetup dictionary
    default: '{"checkout": true}'
  context:
    description: Execution context
    default: '{}'


runs:
  using: "composite"
  steps:
    - name: Set centralized_repo_files_location env var
      shell: bash
      env:
        CENTRALIZED_REPO_FILES_LOCATION: ${{ fromJSON(github.event.inputs.client_payload).payload.centralized_repo_files_location || '' }}
      run: |
        echo "CONFIG_FILE_PATH=/.jit/${CENTRALIZED_REPO_FILES_LOCATION}jit.yml" >> $GITHUB_ENV
        echo "CENTRALIZED_REPO_FILES_LOCATION_PATH=${PWD}/.jit/${CENTRALIZED_REPO_FILES_LOCATION}" >> $GITHUB_ENV

    - name: Checkout centralized repository
      uses: actions/checkout@v3
      with:
        repository: ${{ github.repository }}
        token: ${{ fromJSON(github.event.inputs.client_payload).payload.github_token }}
        ref: ''
        path: ".jit/"

    - name: Checkout original repository
      # this if should pass if there is not runner setup (old flow would checkout always) or when new flow ask to checkout
      if: ${{ ((!(fromJSON(inputs.runner_setup)) || (fromJSON(inputs.runner_setup).checkout == true)))  }}
      uses: actions/checkout@v3
      with:
        repository: ${{ fromJSON(github.event.inputs.client_payload).payload.full_repo_path }}
        ref: ${{ fromJSON(github.event.inputs.client_payload).payload.commits.head_sha }}
        fetch-depth: 0
        token: ${{ fromJSON(github.event.inputs.client_payload).payload.github_token }}
        path: "code/"

    - name: Check out jit-github-actions
      uses: actions/checkout@v3
      with:
        repository: jitsecurity-controls/jit-github-action
        ref: main
        path: ./.github/actions/jit-github-action

    # In order to test using ECR instead of ghcr, a temporary step is added to modify the source registry to ECR
    - name: Set image value
      shell: bash
      run: |
        IMAGE=$(sed "s/ghcr.io\/jitsecurity-controls/registry.jit.io/g" <<< "${{ inputs.security_control }}")
        echo "IMAGE: $IMAGE"
        echo "image=$IMAGE" >> $GITHUB_ENV

    - name: Set cache_file value
      shell: bash
      run: |
        CACHE_FILE=$(sed 's/\//__/g' <<< "${{ env.image }}")  # replace / with __ to avoid / interpreted as directory separator
        echo "CACHE_FILE: $CACHE_FILE" 
        echo "cache_file=$CACHE_FILE" >> $GITHUB_ENV

    - name: Login to docker registry
      shell: bash
      run: |
        START_TIME=$(date +%s)
        curl \
          -X POST \
          -H "Authorization: Bearer ${{ fromJSON(github.event.inputs.client_payload).operational_data.callback_token }}" \
          ${{ fromJSON(github.event.inputs.client_payload).operational_data.callback_urls.base_api }}/authentication/registry/login \
          | docker login --username AWS --password-stdin registry.jit.io
        END_TIME=$(date +%s)
        echo "DEBUG: Authenticating took $((END_TIME - START_TIME)) seconds"

    - name: Get digest
      id: get-digest
      shell: bash
      continue-on-error: true  # We can still run the action even if the manifest doesn't exist
      run: |
        START_TIME=$(date +%s)
        IMAGE_DIGEST=$(docker manifest inspect ${{ env.image }} | jq -r '.config.digest')
        echo "IMAGE_DIGEST: $IMAGE_DIGEST"
        END_TIME=$(date +%s)
        echo "DEBUG: Getting Digest took $((END_TIME - START_TIME)) seconds"
        echo "digest=$IMAGE_DIGEST" >> $GITHUB_ENV

    - name: Docker Image Caching
      uses: actions/cache@v3
      id: cache-docker-image
      with:
        path: ci/cache/docker/${{ env.cache_file }}@${{ env.digest }}.tar
        key: ${{ env.cache_file }}@${{ env.digest }}.tar

    - name: Load image from cache
      if : ${{ steps.cache-docker-image.outputs.cache-hit == 'true' }}
      shell: bash
#      continue-on-error: true
      run: |
        exit 1
        
        echo Loading image from cache
        START_TIME=$(date +%s)
        docker load -i ci/cache/docker/${{ env.cache_file }}@${{ env.digest }}.tar
        END_TIME=$(date +%s)
        echo "DEBUG: Loading (only) the image took $((END_TIME - START_TIME)) seconds"

    - name: Pull image
      shell: bash
      run: |
        echo DOCKER VERSION
        docker --version
        
        START_TIME=$(date +%s)
        docker pull ${{ env.image }}
        END_TIME=$(date +%s)
        echo "DEBUG: Pulling (only) the image took $((END_TIME - START_TIME)) seconds"
        
    - name: Run The Action
      if: always()
      run: |
        B64_ENCODED_GITHUB_EVENT=$(echo $GH_EVENT_JSON | base64)
        echo "Encoded GITHUB EVENT with base64"
        echo CONFIG_FILE_PATH=${CONFIG_FILE_PATH} > /tmp/docker_env.txt
        echo GITHUB_EVENT=$B64_ENCODED_GITHUB_EVENT >> /tmp/docker_env.txt
        echo SOURCE_CODE_FOLDER=/code >> /tmp/docker_env.txt
        echo FAIL_ON_FINDINGS=${{ inputs.fail_on_findings }} >> /tmp/docker_env.txt
        if [ ${{ inputs.security_control_output_file }} != "" ]
        then
          echo SECURITY_CONTROL_OUTPUT_FILE=${{ inputs.security_control_output_file }} >> /tmp/docker_env.txt
        fi
        docker run --rm --env-file /tmp/docker_env.txt ${{ inputs.container_args }} ${{ fromJSON(github.event.inputs.client_payload).payload.control_env_vars }} -v ${CENTRALIZED_REPO_FILES_LOCATION_PATH}:/.jit ${{ env.mount_original_repo_command }} ${{ env.image }} -- ${{ inputs.security_control_args }}
      shell: bash
      env:
        # this field would set the original repo command mount command (would be mounted always in the old flow) and only if checkout = true in the new flow
        mount_original_repo_command: ${{ fromJSON('["","-v $(pwd)/code:/code"]')[((!(fromJSON(inputs.runner_setup)) || (fromJSON(inputs.runner_setup).checkout == true)))] }}
        GH_EVENT_JSON: ${{ toJSON(github) }} # https://github.com/actions/runner/issues/1656#issuecomment-1030077729

    - name: Export image in cache directory
      shell: bash
      if: always()
      run: |
        mkdir -p ci/cache/docker
        docker save ${{ env.image }} -o ci/cache/docker/${{ env.cache_file }}@${{ env.digest }}.tar
        ls -l ci/cache/docker
