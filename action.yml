name: 'Jit security-controls action'
description: 'Runs a Jit security-control on a target dir'
inputs:
  container_args:
    description: 'container additional args'
    required: false
    default: ""
  security_control:
    description: "Docker image tag path of security control to execute"
    required: true
  security_control_output_file:
    description: "path to the security control output"
    required: false
    default: ""
  fail_on_findings:
    description: "fail control when finding is found"
    required: false
    default: "true"
  runner_setup:
    description: RunnerSetup dictionary
    default: '{"checkout": true}'
  inline_environment:
    description: "inline environment variables to be passed to the container"
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    - name: Link job ID to Execution
      shell: bash
      continue-on-error: true
      run: |
        echo "Linking job ID to Jit"
        CI_RUN_ID=${{ fromJSON(github.run_id) }}
        CI_JIT_EVENT_ID=${{ fromJSON(github.event.inputs.client_payload).context.jit_event.jit_event_id }}
        CI_EXECUTION_ID=${{ fromJSON(github.event.inputs.client_payload).execution_data.execution_id }}
        BODY=$( jq -n \
                  --arg vendor_job_id "$CI_RUN_ID" \
                  --arg jit_event_id "$CI_JIT_EVENT_ID" \
                  --arg execution_id "$CI_EXECUTION_ID" \
                  '{vendor_job_id: $vendor_job_id, jit_event_id: $jit_event_id, execution_id: $execution_id}' )
        curl \
          -X POST \
          -H "Authorization: Bearer ${{ fromJSON(github.event.inputs.client_payload).operational_data.callback_token }}" \
          -H "Content-Type: application/json" \
          -d "$BODY" \
          ${{ fromJSON(github.event.inputs.client_payload).operational_data.callback_urls.base_api }}/execution/start

    - id: oidc-auth
      shell: bash
      continue-on-error: true
      run: |
        curl -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" "$ACTIONS_ID_TOKEN_REQUEST_URL" > /dev/null 2>&1

    - shell: bash
      continue-on-error: true
      if: steps.oidc-auth.outcome == 'failure'
      run: |
          curl \
            -X POST \
            -H "Authorization: Bearer ${{ fromJSON(github.event.inputs.client_payload).operational_data.callback_token }}" \
            -H "Content-Type: application/json" \
            -d '{"message": "Failed to request an OIDC Token", "execution_id": "${{ fromJSON(github.event.inputs.client_payload).execution_data.execution_id }}"}' \
            ${{ fromJSON(github.event.inputs.client_payload).operational_data.callback_urls.base_api }}/execution/failure

    - name: Set centralized_repo_files_location env var
      shell: bash
      env:
        CENTRALIZED_REPO_FILES_LOCATION: ${{ fromJSON(github.event.inputs.client_payload).payload.centralized_repo_files_location || '' }}
      run: |
        echo "CONFIG_FILE_PATH=/.jit/${CENTRALIZED_REPO_FILES_LOCATION}jit.yml" >> $GITHUB_ENV
        echo "CENTRALIZED_REPO_FILES_LOCATION_PATH=${PWD}/.jit/${CENTRALIZED_REPO_FILES_LOCATION}" >> $GITHUB_ENV

    - name: Checkout centralized repository
      uses: actions/checkout@v3
      with:
        repository: ${{ github.repository }}
        token: ${{ fromJSON(github.event.inputs.client_payload).payload.github_token }}
        ref: ''
        path: ".jit/"

    - name: Checkout original repository
      # we don't want enrichment to fail the action on empty repo, it has its own logic to handle it
      continue-on-error: true
      id: checkout-original-repo
      # this if should pass if there is not runner setup (old flow would checkout always) or when new flow ask to checkout
      if: ${{ ((!(fromJSON(inputs.runner_setup)) || (fromJSON(inputs.runner_setup).checkout == true)))  }}
      uses: actions/checkout@v3
      with:
        repository: ${{ fromJSON(github.event.inputs.client_payload).payload.full_repo_path }}
        ref: ${{ fromJSON(github.event.inputs.client_payload).payload.commits.head_sha }}
        fetch-depth: 0
        token: ${{ fromJSON(github.event.inputs.client_payload).payload.github_token }}
        path: "code/"

    - name: Exit if checkout failure is fatal
      shell: bash
      if: steps.checkout-original-repo.outcome == 'failure' && fromJSON(github.event.inputs.client_payload).context.job.job_name != 'enrich'
      run: |
        echo "Original repo checkout failed, can't continue job execution"
        exit 1

    - name: Check out jit-github-actions
      uses: actions/checkout@v3
      with:
        repository: jitsecurity-controls/jit-github-action
        ref: main
        path: ./.github/actions/jit-github-action

    # For backward compatability, manually modify the registry value to registry.jit.io
    # TODO: Remove this step once we are fully migrated to registry.jit.io
    - name: Set image value
      id: set-image
      shell: bash
      run: |
        IMAGE=$(sed "s/ghcr.io\/jitsecurity-controls/registry.jit.io/g" <<< "${{ inputs.security_control }}")
        echo "(info) IMAGE: $IMAGE"
        echo "image=$IMAGE" >> $GITHUB_OUTPUT

    # the cache_file is the image name with / replaced with __, we use it to query the cache storage together with the digest
    - name: Set cache_file value
      id: set-cache-file
      continue-on-error: true
      shell: bash
      run: |
        CACHE_FILE=$(sed 's/\//__/g' <<< "${{ steps.set-image.outputs.image }}")  # replace / with __ to avoid / interpreted as directory separator
        echo "(info) CACHE_FILE: $CACHE_FILE" 
        echo "cache_file=$CACHE_FILE" >> $GITHUB_OUTPUT

    - name: Login to docker registry
      shell: bash
      run: |
        curl \
          -X POST \
          -H "Authorization: Bearer ${{ fromJSON(github.event.inputs.client_payload).operational_data.callback_token }}" \
          ${{ fromJSON(github.event.inputs.client_payload).operational_data.callback_urls.base_api }}/authentication/registry/login \
          | docker login --username AWS --password-stdin registry.jit.io

    - uses: actions/cache/restore@v3
      if: steps.set-cache-file.outputs.cache_file != ''
      id: cache-docker-image
      continue-on-error: true
      with:
        path: ci/cache/docker/
        # Instead of attempting to get a cache hit, we just attempt to load the last version of the image from the cache.
        # If the image reference has updated, docker pull will verify that and pull the new version, then we will
        # save the new version to the cache
        key: 'null'
        restore-keys: ${{ steps.set-cache-file.outputs.cache_file }}@

    - name: Load image from cache
      if: steps.cache-docker-image.outputs.cache-matched-key != ''
      shell: bash
      continue-on-error: true
      run: docker load -i ci/cache/docker/${{ steps.cache-docker-image.outputs.cache-matched-key }}

    - name: Pull image
      shell: bash
      run: docker pull ${{ steps.set-image.outputs.image }}

    - name: Run The Action
      if: always()
      run: |
        B64_ENCODED_GITHUB_EVENT=$(echo $GH_EVENT_JSON | base64)
        echo "Encoded GITHUB EVENT with base64"
        echo CONFIG_FILE_PATH=${CONFIG_FILE_PATH} > /tmp/docker_env.txt
        echo GITHUB_EVENT=$B64_ENCODED_GITHUB_EVENT >> /tmp/docker_env.txt
        echo SOURCE_CODE_FOLDER=/code >> /tmp/docker_env.txt
        echo FAIL_ON_FINDINGS=${{ inputs.fail_on_findings }} >> /tmp/docker_env.txt
        if [ ${{ inputs.security_control_output_file }} != "" ]
        then
          echo SECURITY_CONTROL_OUTPUT_FILE=${{ inputs.security_control_output_file }} >> /tmp/docker_env.txt
        fi
        docker run \
          --rm \
          ${{ inputs.inline_environment }} \
          --env-file /tmp/docker_env.txt \
          ${{ inputs.container_args }} \
          -v ${CENTRALIZED_REPO_FILES_LOCATION_PATH}:/.jit \
          ${{ env.mount_original_repo_command }} \
          ${{ steps.set-image.outputs.image }}
      shell: bash
      env:
        # this field would set the original repo command mount command (would be mounted always in the old flow) and only if checkout = true in the new flow
        mount_original_repo_command: ${{ fromJSON('["","-v $(pwd)/code:/code"]')[((!(fromJSON(inputs.runner_setup)) || (fromJSON(inputs.runner_setup).checkout == true)))] }}
        GH_EVENT_JSON: ${{ toJSON(github) }} # https://github.com/actions/runner/issues/1656#issuecomment-1030077729

    - name: Set image id
      if: always()
      id: set-image-id
      shell: bash
      run: |
        IMAGE_ID=$(docker image inspect ${{ steps.set-image.outputs.image }} | jq -r '.[0].Id')
        echo "(info) IMAGE_ID: $IMAGE_ID"
        echo "image_id=$IMAGE_ID" >> $GITHUB_OUTPUT

    - name: Save image in cache directory
      # next if condition verifies we update the cache only the image has changed (based on its id)
      if: always() && !contains(steps.cache-docker-image.outputs.cache-matched-key, steps.set-image-id.outputs.image_id)
      id: save-image
      shell: bash
      run: |
        mkdir -p ci/cache/docker
        if [ -f ci/cache/docker/${{ steps.cache-docker-image.outputs.cache-matched-key }} ]
        then
          echo "(info) Removing old image from cache"
          rm ci/cache/docker/${{ steps.cache-docker-image.outputs.cache-matched-key }}
        fi
        docker save ${{ steps.set-image.outputs.image }} -o ci/cache/docker/${{ steps.set-cache-file.outputs.cache_file }}@${{ steps.set-image-id.outputs.image_id }}.tar

    - uses: actions/cache/save@v3
      if: always() && steps.save-image.conclusion == 'success'
      with:
        path: ci/cache/docker/
        key: ${{ steps.set-cache-file.outputs.cache_file }}@${{ steps.set-image-id.outputs.image_id }}.tar
